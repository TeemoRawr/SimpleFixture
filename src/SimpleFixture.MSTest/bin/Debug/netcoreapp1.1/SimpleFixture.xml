<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleFixture</name>
    </assembly>
    <members>
        <member name="T:SimpleFixture.Attributes.AttributeHelper">
            <summary>
            Reflection helper for fetching attributes
            </summary>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.GetAttribute``1(System.Reflection.MethodInfo)">
            <summary>
            Get attribute on a method, looks on method, then class, then assembly
            </summary>
            <typeparam name="T"></typeparam>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.GetAttributes``1(System.Reflection.MethodInfo)">
            <summary>
            Gets attributes from method, class, then assembly
            </summary>
            <typeparam name="T"></typeparam>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.GetData(System.Reflection.MethodInfo,System.Object[])">
            <summary>Returns the data to be used to test the theory.</summary>
            <param name="testMethod">The method that is being tested</param>
            <param name="parameters"></param>
            <returns>One or more sets of theory data. Each invocation of the test method
            is represented by a single object array.</returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.ProvideValueForParameter(SimpleFixture.Fixture,System.Reflection.ParameterInfo)">
            <summary>
            Override to all inheriting class to provide data for a parameter
            </summary>
            <param name="fixture"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.GenerateValue(SimpleFixture.Fixture,System.Reflection.ParameterInfo,SimpleFixture.Attributes.GenerateAttribute)">
            <summary>
            Generate value for parameter
            </summary>
            <param name="fixture"></param>
            <param name="parameter"></param>
            <param name="generateAttribute"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.LocateValue(SimpleFixture.Fixture,System.Reflection.ParameterInfo,SimpleFixture.Attributes.LocateAttribute)">
            <summary>
            Locate value from fixture
            </summary>
            <param name="fixture"></param>
            <param name="parameter"></param>
            <param name="locateAttribute"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.FreezeValue(SimpleFixture.Fixture,System.Reflection.ParameterInfo,SimpleFixture.Attributes.FreezeAttribute)">
            <summary>
            Freeze value in fixture
            </summary>
            <param name="fixture"></param>
            <param name="parameter"></param>
            <param name="freezeAttribute"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.Freeze``1(SimpleFixture.Fixture,System.Reflection.ParameterInfo,SimpleFixture.Attributes.FreezeAttribute)">
            <summary>
            Freeze a specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fixture"></param>
            <param name="parameter"></param>
            <param name="freezeAttribute"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Attributes.AttributeHelper.CreateFixture(System.Reflection.MethodInfo)">
            <summary>
            Create fixture for method
            </summary>
            <param name="testMethod"></param>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Attributes.ExportAttribute">
            <summary>
            Export specific type to be used in Fixture
            </summary>
        </member>
        <member name="M:SimpleFixture.Attributes.ExportAttribute.#ctor(System.Type)">
            <summary>
            Default constuctor
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:SimpleFixture.Attributes.ExportAttribute.Singleton">
            <summary>
            Singleton
            </summary>
        </member>
        <member name="M:SimpleFixture.Attributes.ExportAttribute.Initialize(SimpleFixture.Fixture)">
            <summary>Initialize fixture</summary>
            <param name="fixture">fixture</param>
        </member>
        <member name="T:SimpleFixture.Attributes.FixtureInitializationAttribute">
            <summary>
            Attribute for initializing fixture
            </summary>
        </member>
        <member name="M:SimpleFixture.Attributes.FixtureInitializationAttribute.Initialize(SimpleFixture.Fixture)">
            <summary>
            Initialize fixture
            </summary>
            <param name="fixture">fixture</param>
        </member>
        <member name="T:SimpleFixture.Attributes.IMethodInfoAware">
            <summary>
            Attributes that implement this interface are aware of being run in context of a method
            </summary>
        </member>
        <member name="T:SimpleFixture.BehaviorCollection">
            <summary>
            A collection of behavior functions to be applied to objects
            </summary>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add(System.Func{SimpleFixture.DataRequest,System.Object,System.Object})">
            <summary>
            Add behavior that will be run against every object returned by the fixture.
            </summary>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add``1(System.Func{SimpleFixture.DataRequest,``0,``0})">
            <summary>
            Add Behavior to be run on specified type
            </summary>
            <typeparam name="T">type of object to apply the behavior to</typeparam>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Add``1(System.Action{``0})">
            <summary>
            Add behavior for specific type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="behavior"></param>
        </member>
        <member name="M:SimpleFixture.BehaviorCollection.Apply(SimpleFixture.DataRequest,System.Object)">
            <summary>
            Apply all the behaviors in the collection to an instance
            </summary>
            <param name="request">data request</param>
            <param name="instance">instance</param>
            <returns>instance</returns>
        </member>
        <member name="T:SimpleFixture.WhenFilter`1">
            <summary>
            Filter for behavior
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.When(System.Func{SimpleFixture.DataRequest,`0,System.Boolean})">
            <summary>
            Execute behavior when func returns true
            </summary>
            <param name="filter">when filter</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.WhenRequestName(System.Func{System.String,System.Boolean})">
            <summary>
            Execute behavior when request name matches
            </summary>
            <param name="filter">filter by request name</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.WhenFilter`1.WhenRequestedFor``1">
            <summary>
            Execute behavior when requested for a particular parent type
            </summary>
            <typeparam name="TRequest"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ArrayConvention">
            <summary>
            Convention for creating array
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.ArrayConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.ArrayConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ArrayConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.BoolConvention">
            <summary>
            convention for creating bool
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.BoolConvention.LocateValue">
            <summary>
            Value return for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.BoolConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.BoolConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ByteConvention">
            <summary>
            Convention for creating byte
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.ByteConvention.LocateValue">
            <summary>
            value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ByteConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.ByteConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.CharConvention">
            <summary>
            Convention for creating random char
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.CharConvention.LocateValue">
            <summary>
            Value that is returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.CharConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.CharConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate char data
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ComplexConvention">
            <summary>
            Convention for creating an populating objects
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ComplexConvention.#ctor(SimpleFixture.IFixtureConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.ComplexConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.ComplexConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ComplexConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.DateTimeConvention">
            <summary>
            Convention for creating datetime
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.DateTimeConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DateTimeConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.DateTimeConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.DecimalConvention">
            <summary>
            Convention for creating decimal
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.DecimalConvention.LocateValue">
            <summary>
            value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DecimalConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.DecimalConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.DelegateConvention">
            <summary>
            Convention for building delegate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DelegateConvention.#ctor(SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="constraintHelper"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.DelegateConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.DelegateConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DelegateConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.DictionaryConvention">
            <summary>
            Convention for creating dictionary
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.DictionaryConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.DictionaryConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DictionaryConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.DoubleConvention">
            <summary>
            convention for creating double
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.DoubleConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.DoubleConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.DoubleConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.EnumConvention">
            <summary>
            Convention for creating enum
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.EnumConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            DEfault constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.EnumConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.EnumConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.EnumConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.FilteredConvention`1">
            <summary>
            Convention for filtering
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.Conventions.FilteredConvention`1.#ctor(System.Func{SimpleFixture.DataRequest,`0},SimpleFixture.ConventionPriority)">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
            <param name="priority"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.FilteredConvention`1.Priority">
            <summary>
            Priority for the convention, last by default
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.FilteredConvention`1.AddFilter(System.Func{SimpleFixture.DataRequest,System.Boolean})">
            <summary>
            Add filter to convention
            </summary>
            <param name="matchingFilter"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.FilteredConvention`1.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.IComparerConvention">
            <summary>
            Convention for creating IComparer
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.IComparerConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.IComparerConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.IComparerConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="P:SimpleFixture.Conventions.IComparerConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.IEqualityComparerConvention">
            <summary>
            Convention for  IEqualityComparer
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.IEqualityComparerConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.IEqualityComparerConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.IEqualityComparerConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="P:SimpleFixture.Conventions.IEqualityComparerConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.IntConvention">
            <summary>
            Convention for creating int
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.IntConvention.LocateValue">
            <summary>
            Locate value for int
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.IntConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.IntConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ListConvention">
            <summary>
            Convention for creating lists
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ListConvention.#ctor(SimpleFixture.IFixtureConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.ListConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.ListConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ListConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="P:SimpleFixture.Conventions.ListConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.LongConvention">
            <summary>
            Convention for creating long
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.LongConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.LongConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default construtor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.LongConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.Named.BaseNamedConvention`1">
            <summary>
            Base convention for type populating using names
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.BaseNamedConvention`1.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="helper"></param>
        </member>
        <member name="P:SimpleFixture.Conventions.Named.BaseNamedConvention`1.Priority">
            <summary>
            Priority for the convention, last by default
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.BaseNamedConvention`1.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate date for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.BaseNamedConvention`1.AddConvention(System.Func{SimpleFixture.DataRequest,`0},System.String[])">
            <summary>
            Add convention func for set of names
            </summary>
            <param name="stringFunc">convention</param>
            <param name="names">names</param>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.BaseNamedConvention`1.Initialize">
            <summary>
            Initialze convention
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.Named.StringNamedConvention">
            <summary>
            Provides strings based on name conventions
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.StringNamedConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="helper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.Named.StringNamedConvention.Initialize">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.NullableConvention">
            <summary>
            Convention for creating nullable
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.NullableConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.NullableConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.NullableConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ReadOnlyCollectionConvention">
            <summary>
            Convention for creating readonly collection
            </summary>
        </member>
        <member name="P:SimpleFixture.Conventions.ReadOnlyCollectionConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.ReadOnlyCollectionConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ReadOnlyCollectionConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="P:SimpleFixture.Conventions.ReadOnlyCollectionConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="T:SimpleFixture.Conventions.SByteConvention">
            <summary>
            Convention for creating sbyte
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.SByteConvention.LocateValue">
            <summary>
            value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.SByteConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.SByteConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ShortConvention">
            <summary>
            Convention for creating short
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.ShortConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ShortConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.ShortConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.SimpleTypeConvention`1">
            <summary>
            Abstract simple type convention
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:SimpleFixture.Conventions.SimpleTypeConvention`1.Priority">
            <summary>
            Priority for the convention, last by default
            </summary>
        </member>
        <member name="E:SimpleFixture.Conventions.SimpleTypeConvention`1.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.SimpleTypeConvention`1.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="P:SimpleFixture.Conventions.SimpleTypeConvention`1.SupportedTypes">
            <summary>
            Supported types
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.SimpleTypeConvention`1.RaisePriorityChanged(SimpleFixture.ConventionPriority)">
            <summary>
            Raise priority changed event
            </summary>
            <param name="priority"></param>
        </member>
        <member name="T:SimpleFixture.Conventions.StringConvention">
            <summary>
            Convention for creating string value
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.StringConvention.LocateValue">
            <summary>
            value returned for lcoate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.StringConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.StringConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.TimeSpanConvention">
            <summary>
            Convention for creating timespan
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.TimeSpanConvention.LocateValue">
            <summary>
            value returned for Locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.TimeSpanConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.TimeSpanConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.TypeConvention">
            <summary>
            Generate random type
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.TypeConvention.LocateType">
            <summary>
            Type returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.TypeConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.TypeConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.UIntConvention">
            <summary>
            Convention for creating uint
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.UIntConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.UIntConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.UIntConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.ULongConvention">
            <summary>
            Convention for creating ulong
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.ULongConvention.LocateValue">
            <summary>
            value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.ULongConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.ULongConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.UriConvention">
            <summary>
            Convention for creating uri
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.UriConvention.LocateValue">
            <summary>
            Value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.UriConvention.#ctor(SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.UriConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.Conventions.UShortConvention">
            <summary>
            Convention returned for ushort
            </summary>
        </member>
        <member name="F:SimpleFixture.Conventions.UShortConvention.LocateValue">
            <summary>
            value returned for locate
            </summary>
        </member>
        <member name="M:SimpleFixture.Conventions.UShortConvention.#ctor(SimpleFixture.Impl.IRandomDataGeneratorService,SimpleFixture.Impl.IConstraintHelper)">
            <summary>
            Default constructor
            </summary>
            <param name="dataGenerator"></param>
            <param name="constraintHelper"></param>
        </member>
        <member name="M:SimpleFixture.Conventions.UShortConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Constrain.NoValue instead of null
            </summary>
            <param name="request">data request</param>
            <returns>generated data</returns>
        </member>
        <member name="T:SimpleFixture.DependencyType">
            <summary>
            Used to explain 
            </summary>
        </member>
        <member name="F:SimpleFixture.DependencyType.Root">
            <summary>
            This is the root of the object request
            </summary>
        </member>
        <member name="F:SimpleFixture.DependencyType.PropertyDependency">
            <summary>
            Request is being used to satify a property
            </summary> 
        </member>
        <member name="F:SimpleFixture.DependencyType.ConstructorDependency">
            <summary>
            Request is being used to satify a constructor
            </summary>
        </member>
        <member name="F:SimpleFixture.DependencyType.Unknown">
            <summary>
            Unknown 
            </summary>
        </member>
        <member name="T:SimpleFixture.DataRequest">
            <summary>
            Object representing a data request
            </summary>
        </member>
        <member name="M:SimpleFixture.DataRequest.#ctor(SimpleFixture.DataRequest,System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="parentRequest">parent request</param>
            <param name="requestedType">new type to create</param>
        </member>
        <member name="M:SimpleFixture.DataRequest.#ctor(SimpleFixture.DataRequest,SimpleFixture.Fixture,System.Type,SimpleFixture.DependencyType,System.String,System.Boolean,System.Object,System.Object)">
            <summary>
            Date request constructor
            </summary>
            <param name="parentRequest">parent request</param>
            <param name="fixture">fixture this request is associated with</param>
            <param name="requestedType">type being requested</param>
            <param name="dependencyType">dependency type</param>
            <param name="requestName">request name for this request</param>
            <param name="populate">populate properties</param>
            <param name="constraints">constraints object</param>
            <param name="extraInfo">extra info (PropertyInfo or ParameterInfo)</param>
        </member>
        <member name="P:SimpleFixture.DataRequest.ParentRequest">
            <summary>
            Parent request
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Fixture">
            <summary>
            Fixture this request is associated with
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestName">
            <summary>
            Request name
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestedType">
            <summary>
            Type being requested
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.DependencyType">
            <summary>
            Dependency Type
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Populate">
            <summary>
            Populate public properties
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Constraints">
            <summary>
            Constraints object for request
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.ExtraInfo">
            <summary>
            Extra Info for request (PropertyInfo or ParameterInfo)
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.RequestDepth">
            <summary>
            Request Depth
            </summary>
        </member>
        <member name="P:SimpleFixture.DataRequest.Instance">
            <summary>
            Instance of object
            </summary>
        </member>
        <member name="T:SimpleFixture.DefaultFixtureConfiguration">
            <summary>
            Default configuration for Fixture
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.AutoWire">
            <summary>
            Configuration with circular reference handling set to AutoWire
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.OmitCircularReferences">
            <summary>
            Configuration with circular refernce handling set to omit
            </summary>
        </member>
        <member name="M:SimpleFixture.DefaultFixtureConfiguration.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.UseDefaultConventions">
            <summary>
            Use default conventions, true by default
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.UseNamedConventions">
            <summary>
            Use named conventions, true by default
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.ItemCount">
            <summary>
            Item count controls the how many instances should be constructed when populating enumerables
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.PopulateProperties">
            <summary>
            Populate properties
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.PopulateFields">
            <summary>
            Populate public fields
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.CircularReferenceHandling">
            <summary>
            Configure how to handle circular references
            </summary>
        </member>
        <member name="P:SimpleFixture.DefaultFixtureConfiguration.UseNonPublicConstructors">
            <summary>
            Use non pubic constructors, false by default
            </summary>
        </member>
        <member name="T:SimpleFixture.DI.GContainer">
            <summary>
            Simple dependency injection container
            </summary>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.Export``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a particular type
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export function</param>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.ExportSingleton``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a type as a singleton
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="exportFunc">export func</param>
        </member>
        <member name="M:SimpleFixture.DI.GContainer.Locate``1">
            <summary>
            Locate an instance of T
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>new instance of T</returns>
        </member>
        <member name="T:SimpleFixture.DI.IGContainer">
            <summary>
            Simple dependency injection container interface
            </summary>
        </member>
        <member name="M:SimpleFixture.DI.IGContainer.Export``1(System.Func{SimpleFixture.DI.GContainer,``0})">
            <summary>
            Export a particular type
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <param name="exportFunc">export function</param>
        </member>
        <member name="M:SimpleFixture.DI.IGContainer.Locate``1">
            <summary>
            Locate instance of T
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <returns>instance of T</returns>
        </member>
        <member name="T:SimpleFixture.ExportAs`1">
            <summary>
            Fluent helper class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ExportAs`1.#ctor(SimpleFixture.Fixture,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="fixture"></param>
            <param name="isSingleton"></param>
        </member>
        <member name="M:SimpleFixture.ExportAs`1.As``1">
            <summary>
            As a specific implementation
            </summary>
            <typeparam name="TExport"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Fixture">
            <summary>
            Testing fixture
            </summary>
        </member>
        <member name="M:SimpleFixture.Fixture.#ctor(SimpleFixture.IFixtureConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="P:SimpleFixture.Fixture.Configuration">
            <summary>
            Configuration for the fixture
            </summary>
        </member>
        <member name="P:SimpleFixture.Fixture.Behavior">
            <summary>
            Allows you to apply a behavior to every object created by the fixture
            </summary>
        </member>
        <member name="M:SimpleFixture.Fixture.Locate(System.Type,System.String,System.Object)">
            <summary>
            Creates a new instance of the specified type. It does not populate any properties
            </summary>
            <param name="type">type to create</param>
            <param name="requestName"></param>
            <param name="constraints"></param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Locate``1(System.String,System.Object)">
            <summary>
            Creates a new instance of T. It does not populate any properties
            </summary>
            <typeparam name="T">type to create</typeparam>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate(SimpleFixture.DataRequest)">
            <summary>
            Create a new instance of the requested type and populate all public writable properties
            </summary>
            <param name="request">data request</param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate(System.Type,System.String,System.Object)">
            <summary>
            Generate a new instance of the specified type and populate public writable properties
            </summary>
            <param name="type">type to create</param>
            <param name="name">name of the request</param>
            <param name="constraints">constraints to apply to the request</param>
            <returns>new instance</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Generate``1(System.String,System.Object)">
            <summary>
            Generate a new instance of T and populate public writable properties
            </summary>
            <typeparam name="T">type to create</typeparam>
            <param name="name">request name</param>
            <param name="constraints">constraint object</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Freeze``1(System.String,System.Object,System.Action{SimpleFixture.ReturnConfiguration{``0}})">
            <summary>
            Generate a new value and add it to the Fixture as a Return
            </summary>
            <typeparam name="T">type to generate</typeparam>
            <param name="requestName">request name</param>
            <param name="constraints">constraints for generate</param>
            <param name="value">action to specify when to use the froozen value (value: i => i.For&lt;T&gt;)</param>
            <returns>new T</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Populate(System.Object,System.Object)">
            <summary>
            Populate writable properties on instance
            </summary>
            <param name="instance">instance to populate</param>
            <param name="constraints">constraint object</param>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(``0[])">
            <summary>
            Return the specified sequence
            </summary>
            <typeparam name="T">Type to return</typeparam>
            <param name="returnValues">return values</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(System.Func{``0})">
            <summary>
            Provide a function that will be invoked when T is need
            </summary>
            <typeparam name="T">type to return</typeparam>
            <param name="returnFunc">return function</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Return``1(System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Provide a function that will be invoked when T is need
            </summary>
            <typeparam name="T">type to return</typeparam>
            <param name="returnFunc">return function</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ReturnIEnumerable``1(``0[])">
            <summary>
            Return a set of T as an IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">T Type for IEnumerable</typeparam>
            <param name="set">set of T</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.Export``1">
            <summary>
            Export specific implementation as an interface, you must call As after
            </summary>
            <typeparam name="T">Type being exported</typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ExportAs``2">
            <summary>
            Export a type as something
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TExport"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ExportSingleton``1">
            <summary>
            Export specific implemantion as a singleton interface, you must call As after
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ExportSingletonAs``2">
            <summary>
            Export specific implemantion as a singleton interface
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <typeparam name="TExport">exporting interface</typeparam>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.ExportAllByInterface">
            <summary>
            Export a set of types by interface
            </summary>
        </member>
        <member name="M:SimpleFixture.Fixture.Add(SimpleFixture.IConvention)">
            <summary>
            Add a convention to fixture
            </summary>
            <param name="convention">new convention</param>
        </member>
        <member name="M:SimpleFixture.Fixture.Add(SimpleFixture.IFixtureCustomization)">
            <summary>
            Add customization
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:SimpleFixture.Fixture.Customize``1">
            <summary>
            Customize the creation of a particular type
            </summary>
            <typeparam name="T">type ot customize</typeparam>
            <returns>customize object</returns>
        </member>
        <member name="M:SimpleFixture.Fixture.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Fixture.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Convention">
            <summary>
            class with special values
            </summary>
        </member>
        <member name="F:SimpleFixture.Convention.NoValue">
            <summary>
            Value to return instead of null
            </summary>
        </member>
        <member name="T:SimpleFixture.ConventionPriority">
            <summary>
            Convention priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.First">
            <summary>
            First convention to try
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.High">
            <summary>
            High priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Normal">
            <summary>
            Normal priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Low">
            <summary>
            Low priority
            </summary>
        </member>
        <member name="F:SimpleFixture.ConventionPriority.Last">
            <summary>
            Last convention tried
            </summary>
        </member>
        <member name="T:SimpleFixture.PriorityChangedEventArgs">
            <summary>
            Event args for when priority changes
            </summary>
        </member>
        <member name="F:SimpleFixture.PriorityChangedEventArgs.Priority">
            <summary>
            Priority
            </summary>
        </member>
        <member name="T:SimpleFixture.IConvention">
            <summary>
            Convention for satisifying a data request
            </summary>
        </member>
        <member name="P:SimpleFixture.IConvention.Priority">
            <summary>
            Prioirity the convention should be looked at
            </summary>
        </member>
        <member name="E:SimpleFixture.IConvention.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.IConvention.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request, return Convention.NoValue if the convention has no value to provide
            </summary>
            <param name="request">data request</param>
            <returns>generated data value</returns>
        </member>
        <member name="T:SimpleFixture.ICustomizeModel`1">
            <summary>
            Interface for customizing how a Type gets created
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.New(System.Func{`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">function to create new T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.New(System.Func{SimpleFixture.DataRequest,`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">delegate that accepts a data request and returns T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``1(System.Func{``0,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn
            </summary>
            <typeparam name="TIn">type for dependency</typeparam>
            <param name="factory">new factory that takes TIn</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``2(System.Func{``0,``1,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1 and TIn2
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <param name="factory">new factory that takes TIn1 and TIn2</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, and TIn3
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, and TIn3</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.NewFactory``4(System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, TIn3, and TIn4
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <typeparam name="TIn4">fourth dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, TIn3, and TIn4</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="value">value to use when setting property</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Object)">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">property value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Skip``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Skip a particular property from being populated
            </summary>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">property expression</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SkipProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.SkipProperties(System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.ICustomizeModel`1.Apply(System.Action{`0})">
            <summary>
            Apply a piece of logic to each instance being created
            </summary>
            <param name="applyAction">apply function</param>
            <returns>customization instanc</returns>
        </member>
        <member name="T:SimpleFixture.CircularReferenceHandlingAlgorithm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SimpleFixture.CircularReferenceHandlingAlgorithm.MaxDepth">
            <summary>
            Throws an exception when a max depth is reached, this is the original algorithm
            </summary>
        </member>
        <member name="F:SimpleFixture.CircularReferenceHandlingAlgorithm.OmitCircularReferences">
            <summary>
            Omit circular properties, skips properties that are circular and returns empty collections when circular
            </summary>
        </member>
        <member name="F:SimpleFixture.CircularReferenceHandlingAlgorithm.AutoWire">
            <summary>
            Autowire circular references, if a parent in the object graph can be used it will be
            </summary>
        </member>
        <member name="T:SimpleFixture.IFixtureConfiguration">
            <summary>
            Configuration interface for SimpleFixture. Only implement this interface if you want to change the internal worksings of SimpleFixture
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.UseDefaultConventions">
            <summary>
            Use default conventions for primitive types as well as string
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.UseNamedConventions">
            <summary>
            Use conventions that try and assign values based on parameter or property names
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.ItemCount">
            <summary>
            If set this will indicate how many items to generate for IEnumerables and other colletions.
            If null then the convention is free to do what it wants
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.PopulateProperties">
            <summary>
            Populate public properties
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.PopulateFields">
            <summary>
            Populate public fields
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.CircularReferenceHandling">
            <summary>
            How to handle circular references
            </summary>
        </member>
        <member name="P:SimpleFixture.IFixtureConfiguration.UseNonPublicConstructors">
            <summary>
            Use non pubic constructors, false by default
            </summary>
        </member>
        <member name="T:SimpleFixture.IFixtureCustomization">
            <summary>
            This interface allows you to package a set of customization for reuse. 
            </summary>
        </member>
        <member name="M:SimpleFixture.IFixtureCustomization.Customize(SimpleFixture.Fixture)">
            <summary>
            Customize the fixture
            </summary>
            <param name="fixture">fixture to customize</param>
        </member>
        <member name="T:SimpleFixture.Impl.ICircularReferenceHandler">
            <summary>
            interface to handle circular references
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.ICircularReferenceHandler.HandleCircularReference(SimpleFixture.DataRequest)">
            <summary>
            Handle circular reference
            </summary>
            <param name="request">data request that has caused the circular reference</param>
            <returns>data request value</returns>
        </member>
        <member name="T:SimpleFixture.Impl.CircularReferenceHandler">
            <summary>
            Default implementation of ICircularReferenceHandler, throws an exception
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.CircularReferenceHandler.HandleCircularReference(SimpleFixture.DataRequest)">
            <summary>
            Handle circular reference
            </summary>
            <param name="request">data request that has caused the circular reference</param>
            <returns>data request value</returns>
        </member>
        <member name="T:SimpleFixture.Impl.MinMaxValue`1">
            <summary>
            Min max value for a specific type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:SimpleFixture.Impl.MinMaxValue`1.Min">
            <summary>
            Min value
            </summary>
        </member>
        <member name="P:SimpleFixture.Impl.MinMaxValue`1.Max">
            <summary>
            Max value
            </summary>
        </member>
        <member name="T:SimpleFixture.Impl.IConstraintHelper">
            <summary>
            Constraint helper get's values from a contraint object
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.IConstraintHelper.GetValue``1(System.Object,``0,System.String[])">
            <summary>
            Get value from a constraint object
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="constraintValue"></param>
            <param name="defaultValue"></param>
            <param name="propertyNames"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Impl.IConstraintHelper.GetUnTypedValue(System.Object@,System.Type,System.Object,System.Object,System.String[])">
            <summary>
            Get untyped value from constraint object
            </summary>
            <param name="valueType"></param>
            <param name="constraintValue"></param>
            <param name="defaultValue"></param>
            <param name="propertyNames"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Impl.IConstraintHelper.GetMinMax``1(SimpleFixture.DataRequest,``0,``0)">
            <summary>
            Get min max for data request
            </summary>
            <typeparam name="T"></typeparam>
            <param name="request"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Impl.IConstraintValueProvider">
            <summary>
            Constraint objects that implement this interface can be queried to provide values
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.IConstraintValueProvider.ProvideValue(System.Type,System.Object,System.String[])">
            <summary>
            Provide value
            </summary>
            <param name="valueType"></param>
            <param name="defualtValue"></param>
            <param name="propertyNames"></param>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.Impl.CustomizeModel`1">
            <summary>
            Object used to customize a model
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.#ctor(SimpleFixture.Impl.ComplexModel)">
            <summary>
            Default Constructor
            </summary>
            <param name="complexModel"></param>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.New(System.Func{`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">function to create new T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.New(System.Func{SimpleFixture.DataRequest,`0})">
            <summary>
            Provide a function for creating a new instance of T
            </summary>
            <param name="newFunc">delegate that accepts a data request and returns T</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``1(System.Func{``0,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn
            </summary>
            <typeparam name="TIn">type for dependency</typeparam>
            <param name="factory">new factory that takes TIn</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``2(System.Func{``0,``1,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1 and TIn2
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <param name="factory">new factory that takes TIn1 and TIn2</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, and TIn3
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, and TIn3</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.NewFactory``4(System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Provide function for creating a new instance of T that depends on TIn1, TIn2, TIn3, and TIn4
            </summary>
            <typeparam name="TIn1">first dependency type</typeparam>
            <typeparam name="TIn2">second dependency type</typeparam>
            <typeparam name="TIn3">third dependency type</typeparam>
            <typeparam name="TIn4">fourth dependency type</typeparam>
            <param name="factory">new factory that takes TIn1, TIn2, TIn3, and TIn4</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="value">value to use when setting property</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{SimpleFixture.DataRequest,``0})">
            <summary>
            Set a value for a particular property on T
            </summary>
            <typeparam name="TProp">type of property to set</typeparam>
            <param name="propertyFunc">method to specify property (x => x.PropertyName)</param>
            <param name="valueFunc">function to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Object)">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">property value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SetProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Object})">
            <summary>
            Set a specific value into a set of Properties specified by the matching func
            </summary>
            <param name="matchingFunc">property matching func</param>
            <param name="value">func to be used to provide value</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Skip``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Skip a particular property from being populated
            </summary>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">property expression</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SkipProperties(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.SkipProperties(System.Func{SimpleFixture.DataRequest,System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Skip a particular set of properties
            </summary>
            <param name="matchingFunc">property matching function</param>
            <returns>customization instance</returns>
        </member>
        <member name="M:SimpleFixture.Impl.CustomizeModel`1.Apply(System.Action{`0})">
            <summary>
            Apply a piece of logic to each instance being created
            </summary>
            <param name="applyAction">apply function</param>
            <returns>customization instanc</returns>
        </member>
        <member name="T:SimpleFixture.Impl.StringType">
            <summary>
            Type of string to return
            </summary>
        </member>
        <member name="F:SimpleFixture.Impl.StringType.MostCharacter">
            <summary>
            Mostly characters
            </summary>
        </member>
        <member name="F:SimpleFixture.Impl.StringType.Alpha">
            <summary>
            Alpha only
            </summary>
        </member>
        <member name="F:SimpleFixture.Impl.StringType.AlphaNumeric">
            <summary>
            Alpha numeric
            </summary>
        </member>
        <member name="F:SimpleFixture.Impl.StringType.Numeric">
            <summary>
            Numeric only
            </summary>
        </member>
        <member name="F:SimpleFixture.Impl.StringType.LoremIpsum">
            <summary>
            Lorem Ipsum
            </summary>
        </member>
        <member name="T:SimpleFixture.Impl.IRandomDataGeneratorService">
            <summary>
            Interface for generating random data
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextString(SimpleFixture.Impl.StringType,System.Int32,System.Int32)">
            <summary>
            Generate the next string
            </summary>
            <param name="stringType">type of string to return</param>
            <param name="min">min string length</param>
            <param name="max">max string length</param>
            <returns>random string</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextBool">
            <summary>
            Next random bool
            </summary>
            <returns>random bool</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextChar(System.Char,System.Char)">
            <summary>
            Next random char
            </summary>
            <param name="min">min character</param>
            <param name="max">max character</param>
            <returns>random character</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextCharacter">
            <summary>
            Next random alpha character
            </summary>
            <returns>random character</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextByte(System.Byte,System.Byte)">
            <summary>
            Next random byte
            </summary>
            <param name="min">min byte value</param>
            <param name="max">max byte value</param>
            <returns>random byte</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextSByte(System.SByte,System.SByte)">
            <summary>
            Next random signed byte
            </summary>
            <param name="min">min sbyte</param>
            <param name="max">max sbyte</param>
            <returns>random sbyte</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextShort(System.Int16,System.Int16)">
            <summary>
            Next random short
            </summary>
            <param name="min">min short</param>
            <param name="max">max short</param>
            <returns>random short</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextUShort(System.UInt16,System.UInt16)">
            <summary>
            Next random ushort
            </summary>
            <param name="min">min ushort</param>
            <param name="max">max ushort</param>
            <returns>random ushort</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextInt(System.Int32,System.Int32)">
            <summary>
            Next random int
            </summary>
            <param name="min">min int</param>
            <param name="max">max int</param>
            <returns>random int</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Next random unit
            </summary>
            <param name="min">min unit</param>
            <param name="max">max uint</param>
            <returns>random uint</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextLong(System.Int64,System.Int64)">
            <summary>
            Next random long
            </summary>
            <param name="min">min long</param>
            <param name="max">max long</param>
            <returns>random long</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextULong(System.UInt64,System.UInt64)">
            <summary>
            Next random ulong
            </summary>
            <param name="min">min ulon</param>
            <param name="max">max ulong</param>
            <returns>random ulong</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextDouble(System.Double,System.Double)">
            <summary>
            Next random double
            </summary>
            <param name="min">min double</param>
            <param name="max">max double</param>
            <returns>random double</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextDecimal(System.Nullable{System.Decimal},System.Nullable{System.Decimal})">
            <summary>
            Next random decimal
            </summary>
            <param name="min">min decimal</param>
            <param name="max">max decimal</param>
            <returns>random decimal</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextDateTime(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Next random date time
            </summary>
            <param name="min">min datetime</param>
            <param name="max">max datetime</param>
            <returns>random datetime</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextTimeSpan(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Next random timespan
            </summary>
            <param name="min">min timespan</param>
            <param name="max">max timespan</param>
            <returns>random timespan</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextEnum(System.Type)">
            <summary>
            Next random enum value
            </summary>
            <param name="enumType">type of enum</param>
            <returns>enum</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextEnum``1">
            <summary>
            Next random enum 
            </summary>
            <typeparam name="T">type of enum</typeparam>
            <returns>random enum</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextInSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Next random value in set
            </summary>
            <typeparam name="T">type of set</typeparam>
            <param name="set">set</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.NextT``1(``0[])">
            <summary>
            Next random value in set
            </summary>
            <typeparam name="T"></typeparam>
            <param name="set">set</param>
            <returns>random value</returns>
        </member>
        <member name="M:SimpleFixture.Impl.IRandomDataGeneratorService.Randomize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Randomize a set of values
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="set">set</param>
            <returns>randomized set</returns>
        </member>
        <member name="T:SimpleFixture.Impl.RandomDataGeneratorService">
            <summary>
            Class for generating random data
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextUShort(System.UInt16,System.UInt16)">
            <summary>
            Next random ushort
            </summary>
            <param name="min">min ushort</param>
            <param name="max">max ushort</param>
            <returns>random ushort</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextInt(System.Int32,System.Int32)">
            <summary>
            Next random int
            </summary>
            <param name="min">min int</param>
            <param name="max">max int</param>
            <returns>random int</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Next random unit
            </summary>
            <param name="min">min unit</param>
            <param name="max">max uint</param>
            <returns>random uint</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextLong(System.Int64,System.Int64)">
            <summary>
            Next random long
            </summary>
            <param name="min">min long</param>
            <param name="max">max long</param>
            <returns>random long</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextULong(System.UInt64,System.UInt64)">
            <summary>
            Next random ulong
            </summary>
            <param name="min">min ulon</param>
            <param name="max">max ulong</param>
            <returns>random ulong</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextDecimal(System.Nullable{System.Decimal},System.Nullable{System.Decimal})">
            <summary>
            Next random decimal
            </summary>
            <param name="min">min decimal</param>
            <param name="max">max decimal</param>
            <returns>random decimal</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextEnum(System.Type)">
            <summary>
            Next random enum value
            </summary>
            <param name="enumType">type of enum</param>
            <returns>enum</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextEnum``1">
            <summary>
            Next random enum 
            </summary>
            <typeparam name="T">type of enum</typeparam>
            <returns>random enum</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextInSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Next random value in set
            </summary>
            <typeparam name="T">type of set</typeparam>
            <param name="set">set</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextT``1(``0[])">
            <summary>
            Next random value in set
            </summary>
            <typeparam name="T"></typeparam>
            <param name="set">set</param>
            <returns>random value</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.Randomize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Randomize a set of values
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="set">set</param>
            <returns>randomized set</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextString(SimpleFixture.Impl.StringType,System.Int32,System.Int32)">
            <summary>
            Generate the next string
            </summary>
            <param name="stringType">type of string to return</param>
            <param name="min">min string length</param>
            <param name="max">max string length</param>
            <returns>random string</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextDouble(System.Double,System.Double)">
            <summary>
            Next random double
            </summary>
            <param name="min">min double</param>
            <param name="max">max double</param>
            <returns>random double</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextBool">
            <summary>
            Next random bool
            </summary>
            <returns>random bool</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextChar(System.Char,System.Char)">
            <summary>
            Next random char
            </summary>
            <param name="min">min character</param>
            <param name="max">max character</param>
            <returns>random character</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextCharacter">
            <summary>
            Next random alpha character
            </summary>
            <returns>random character</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextByte(System.Byte,System.Byte)">
            <summary>
            Next random byte
            </summary>
            <param name="min">min byte value</param>
            <param name="max">max byte value</param>
            <returns>random byte</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextSByte(System.SByte,System.SByte)">
            <summary>
            Next random signed byte
            </summary>
            <param name="min">min sbyte</param>
            <param name="max">max sbyte</param>
            <returns>random sbyte</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextShort(System.Int16,System.Int16)">
            <summary>
            Next random short
            </summary>
            <param name="min">min short</param>
            <param name="max">max short</param>
            <returns>random short</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextDateTime(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Next random date time
            </summary>
            <param name="min">min datetime</param>
            <param name="max">max datetime</param>
            <returns>random datetime</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.NextTimeSpan(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Next random timespan
            </summary>
            <param name="min">min timespan</param>
            <param name="max">max timespan</param>
            <returns>random timespan</returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.BuildString(System.Collections.Generic.List{System.Char},System.Int32,System.Int32)">
            <summary>
            Build random string
            </summary>
            <param name="characters">character list</param>
            <param name="min">min string length</param>
            <param name="max">max string length</param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.SetupAlphaCharacters">
            <summary>
            Setup alpha character set
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.SetupNumericCharacters">
            <summary>
            Setup numeric character set
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.SetupAlphaNumericCharacters">
            <summary>
            Setup alpha numeric characters
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.SetupAllCharacters">
            <summary>
            Setup a list of call charactes
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.RandomDataGeneratorService.BuildLoremIpsum(System.Int32,System.Int32)">
            <summary>
            Build a lorem ipsum string
            </summary>
            <param name="min">min string size</param>
            <param name="max">max string size</param>
            <returns>random string</returns>
        </member>
        <member name="T:SimpleFixture.Impl.TypedConventions">
            <summary>
            Convention that handles ITypeConvention
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.#ctor(SimpleFixture.IFixtureConfiguration,SimpleFixture.ConventionPriority)">
            <summary>
            Default constructor
            </summary>
            <param name="configuration"></param>
            <param name="priority"></param>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.AddConvention(SimpleFixture.ITypedConvention)">
            <summary>
            Add typed convention
            </summary>
            <param name="typedConvention">convention</param>
        </member>
        <member name="P:SimpleFixture.Impl.TypedConventions.Priority">
            <summary>
            Priority for convention
            </summary>
        </member>
        <member name="E:SimpleFixture.Impl.TypedConventions.PriorityChanged">
            <summary>
            Priorit changed event
            </summary>
        </member>
        <member name="M:SimpleFixture.Impl.TypedConventions.GenerateData(SimpleFixture.DataRequest)">
            <summary>
            Generate data for the request
            </summary>
            <param name="request">data request</param>
            <returns></returns>
        </member>
        <member name="T:SimpleFixture.ITypedConvention">
            <summary>
            Conventions implementing this interface support a specific set of types
            </summary>
        </member>
        <member name="P:SimpleFixture.ITypedConvention.SupportedTypes">
            <summary>
            Types the convention supports
            </summary>
        </member>
        <member name="T:SimpleFixture.ReturnConfiguration`1">
            <summary>
            Class used to configure when a return value should be used
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.#ctor(SimpleFixture.Conventions.FilteredConvention{`0},SimpleFixture.Fixture)">
            <summary>
            Default constructor
            </summary>
            <param name="convention">filter convention</param>
            <param name="fixture"></param>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.For``1">
            <summary>
            Use return value for specific parent types
            </summary>
            <typeparam name="TValue">filter type</typeparam>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.For(System.Type)">
            <summary>
            Use return value for specific parent types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenNamed(System.String)">
            <summary>
            Filter based on name (Parameter name or Property name)
            </summary>
            <param name="name">name to match exactly</param>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenNamed(System.Func{System.String,System.Boolean})">
            <summary>
            Filter based on name function (Parameter name or Property name)
            </summary>
            <param name="namedFunc">name func used to filter</param>
            <returns>return configuration</returns>
        </member>
        <member name="M:SimpleFixture.ReturnConfiguration`1.WhenMatching(System.Func{SimpleFixture.DataRequest,System.Boolean})">
            <summary>
            Filter based on data request
            </summary>
            <param name="matchingFunc">filter method</param>
            <returns>return configuration</returns>
        </member>
    </members>
</doc>
